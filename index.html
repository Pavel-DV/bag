<!DOCTYPE html>
<html>
<head><title>Bag</title>
    <!--    <meta name="apple-mobile-web-app-capable" content="yes">-->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <style>
        html {
            background-color: black;
        }

        body {
            color: white;
            margin: 0 auto;
            width: 100vw;
            padding: 0 0;
            height: 100vh;
        }
    </style>
</head>
<body>
<div id="pics" style="width: 100%; display: flex; flex-direction: column; ">
</div>

<script>
    'use strict'

    async function decryptMessage(key, ciphertext, iv) {
        return await window.crypto.subtle.decrypt(
            {
                name: 'AES-CBC',
                iv,
                // length: 16,
            },
            key,
            ciphertext,
        ).catch(e =>
            console.log(e)
        )
    }

    const fetchFile = async fileName => {
        const myRequest = new Request(`./pics/${fileName}`)
        const response = await fetch(myRequest)

        return await response.arrayBuffer()
    }

    const decryptFile = passHash16 => async file => {
        const buf = await Promise.all(file.chunks.map(fetchFile)).then(bufs => new Blob(bufs).arrayBuffer())

        const key = await window.crypto.subtle.importKey(
            'raw',
            passHash16,
            'AES-CBC',
            true,
            [ 'encrypt', 'decrypt' ],
        )

        const counter = await getHash(file.name)

        return { data: await decryptMessage(key, buf, counter), file }
    }

    const mediaOnError = passHash16 => async e => {
        e.target.onerror = null
        const decrypted = await decryptFile(passHash16)(e.target.file)
        e.target.src = window.URL.createObjectURL(new Blob([ decrypted.data ], { type: decrypted.file.type }))
    }

    const createDummyElement = passHash16 => file => {
        const type = file.type === 'image/jpg' ? 'img' : 'video'

        const style = {
            width: '100%',
            height: '100vh',
            objectFit: 'contain'
        }

        const extraAttrs = type === 'video' ? {
            controls: true,
        } : {}

        const attrs = {
            loading: 'lazy',
            src: `data:,${file.name}`,
            onerror: mediaOnError(passHash16),
            ...extraAttrs
        }

        const newElement = document.createElement(type)

        // Object.keys(attrs).forEach(key => newElement.setAttribute(key, attrs[key]));

        Object.assign(newElement, attrs)
        Object.assign(newElement.style, style)
        newElement.file = file
        newElement.setAttribute('playsinline', '')  //  for video

        return newElement
    }

    async function getHash(text) {
        const uint8encoded = new TextEncoder().encode(text)
        const longHash = await crypto.subtle.digest('SHA-1', uint8encoded)

        return new Uint8Array(longHash, 0, 16)
    }

    const enc = s => new TextEncoder().encode(s);
    const dec = b => new TextDecoder().decode(b);

    const deriveWrapKey = async prf =>
        crypto.subtle.deriveKey(
            {
                name: "HKDF",
                hash: "SHA-256",
                salt: new Uint8Array(16),
                info: enc("wrap-page-key"),
            },
            await crypto.subtle.importKey("raw", prf, "HKDF", false, ["deriveKey"]),
            { name: "AES-GCM", length: 256 },
            false,
            ["encrypt", "decrypt"]
        );

    const b64 = {
        e: u8 => btoa(String.fromCharCode(...u8)),
        d: s => Uint8Array.from(atob(s), c => c.charCodeAt(0)),
    };

    const PRF_SALT = (() => {
        const s = localStorage.getItem("prfSalt");
        if (s) return b64.d(s);

        const v = crypto.getRandomValues(new Uint8Array(32));
        localStorage.setItem("prfSalt", b64.e(v));
        return v;
    })();

    (async () => {
        await ensureCredential();
        const pics = document.getElementById('pics')
        const passHash16 = await getHash(dec(await unwrapKey()))
        const { default: files } = await import('./files.json', { with: { type: "json" } })

        const dummyImages = files.map(createDummyElement(passHash16))
        pics.append(...dummyImages)
    })()

    const prfBytesOnce = (() => {
        const cache = { value: null };

        return async () => {
            if (cache.value) return cache.value;

            const a = await navigator.credentials.get({
                publicKey: {
                    challenge: crypto.getRandomValues(new Uint8Array(32)),
                    userVerification: "required",
                    extensions: { prf: { eval: { first: PRF_SALT } } },
                },
            });

            const prf = a.getClientExtensionResults().prf?.results?.first;
            if (!prf) throw new Error("PRF not supported");

            cache.value = prf;
            return prf;
        };
    })();


    async function wrapKey(rawBytes) {
        const key = await deriveWrapKey(await prfBytesOnce());
        const iv = crypto.getRandomValues(new Uint8Array(12));
        const data = await crypto.subtle.encrypt(
            { name: "AES-GCM", iv },
            key,
            rawBytes
        );

        localStorage.setItem("wrappedKeyIv", b64.e(iv));
        localStorage.setItem("wrappedKeyData", b64.e(new Uint8Array(data)));
    }

    async function unwrapKey() {
        const ivB64 = localStorage.getItem("wrappedKeyIv");
        const dataB64 = localStorage.getItem("wrappedKeyData");

        // first run: no wrapped key â†’ ask user
        if (!ivB64 || !dataB64) {
            const password = prompt("Password");
            if (!password) throw new Error("No password");

            const raw = enc(password);
            await wrapKey(raw);
            return raw;
        }

        // normal path: WebAuthn unlock
        const key = await deriveWrapKey(await prfBytesOnce());
        const iv = b64.d(ivB64);
        const data = b64.d(dataB64);

        const plain = await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, data);
        return new Uint8Array(plain);
    }

    async function ensureCredential() {
        if (localStorage.getItem("wrappedKeyData")) return;

        await navigator.credentials.create({
            publicKey: {
                challenge: crypto.getRandomValues(new Uint8Array(32)),
                rp: { name: "Local Protected Media" },
                user: {
                    id: crypto.getRandomValues(new Uint8Array(32)),
                    name: "local",
                    displayName: "local"
                },
                pubKeyCredParams: [
                    { type: "public-key", alg: -7 },
                    { type: "public-key", alg: -257 }
                ],
                authenticatorSelection: {
                    authenticatorAttachment: "platform",
                    userVerification: "required"
                },
                extensions: { prf: {} }
            }
        });

        // iOS Safari needs a reload after create
        location.reload();
    }


    // ---- usage ----
    // const password = dec(await unwrapKey());
    
</script>
</body>
</html>
